(require 'vec3)

(cl-defstruct quat x y z w)

(defun quat-mult (q1 q2)
  (make-quat :x (+ (* (quat-w q1) (quat-x q2))
                   (* (quat-x q1) (quat-w q2))
                   (* (quat-y q1) (quat-z q2))
                   (- (* (quat-z q1) (quat-y q2))))
             :y (+ (* (quat-w q1) (quat-y q2))
                   (- (* (quat-x q1) (quat-z q2)))
                   (* (quat-y q1) (quat-w q2))
                   (* (quat-z q1) (quat-x q2)))
             :z (+ (* (quat-w q1) (quat-z q2))
                   (* (quat-x q1) (quat-y q2))
                   (- (* (quat-y q1) (quat-x q2)))
                   (* (quat-z q1) (quat-w q2)))
             :w (+ (* (quat-w q1) (quat-w q2))
                   (- (+ (* (quat-x q1) (quat-x q2))))
                   (- (+ (* (quat-y q1) (quat-y q2))))
                   (- (+ (* (quat-z q1) (quat-z q2)))))))

(defun quat-norm (q)
  (sqrt (+ (expt (quat-x q) 2)
           (expt (quat-y q) 2)
           (expt (quat-z q) 2)
           (expt (quat-w q) 2))))

(defun quat-scale (q s)
  (make-quat :x (* (quat-x q) s)
             :y (* (quat-y q) s)
             :z (* (quat-z q) s)
             :w (* (quat-w q) s)))

(defun quat-normalize (q)
  (let ((n (quat-norm q)))
    (if (= n 0)
        (error "cannot normalize zero quat")
      (quat-scale q (/ 1 n)))))

(defun quat-conjugate (q)
  (make-quat :x (* -1 (quat-x q))
             :y (* -1 (quat-y q))
             :z (* -1 (quat-z q))
             :w (quat-w q)))

(defun quat-inverse (q)
  (let ((norm (quat-norm q)))
    (if (= norm 0)
        (error "cannot inverse a zero normed quaternion")
      (quat-scale (quat-conjugate q) norm))))

(defun quat-identity ()
  (make-quat :x 0 :y 0 :z 0 :w 1))

(defun make-quat-angle-axis (angle axis)
  (let* ((halfangle (/ angle 2))
         (sine (sin halfangle))
         (cosine (cos halfangle)))
    (make-quat :x (* sine (vec3-x axis))
               :y (* sine (vec3-y axis))
               :z (* sine (vec3-z axis))
               :w cosine)))

(defun quat-angle (q)
  (acos (* 2 (quat-w q))))

(defun quat-axis (q)
  (let ((scale (asin (* (quat-w q) 2))))
    (make-vec3 :x (* (quat-x q) scale)
               :y (* (quat-y q) scale)
               :z (* (quat-z q) scale))))

(defun quat-apply (q v)
  (let* ((vq (make-quat :x (vec3-x v) :y (vec3-y v) :z (vec3-z v) :w 0))
         (res (quat-mult (quat-mult q vq) (quat-conjugate q))))
    (make-vec3 :x (quat-x res) :y (quat-y res) :z (quat-z res))))

(ert-deftest test-quat-norm ()
  (let* ((q (make-quat :x 1 :y 2 :z 3 :w 4)))
    (should (= (quat-norm q) (sqrt 30)))
    (should (= (quat-norm (quat-identity)) 1))))

(ert-deftest test-quat-scale ()
  (let* ((q (make-quat :x 1 :y 2 :z 3 :w 4)))
    (should (= (quat-norm (quat-scale q 3)) (* 3 (sqrt 30))))
    (should (= (quat-norm (quat-scale q 3)) (* 3 (quat-norm q))))))

(ert-deftest test-quat-normalize ()
  (should (= (quat-norm (quat-normalize (make-quat :x 123 :y 456 :z 789 :w 101112))) 1))
  (should (= (quat-norm (quat-normalize (make-quat :x 0 :y 0 :z 0 :w 2))) 1))
  ;(should (= (quat-norm (quat-normalize (make-quat :x 0 :y 0 :z 0 :w 0))) 1))
  )

(ert-deftest test-quat-mult ()
  (let ((q (make-quat :x 1 :y 2 :z 3 :w 4)))
    (should (= (quat-norm (quat-mult q (quat-identity))) (quat-norm q)))
    (should (equal (quat-mult q (quat-identity)) q))
    (should (equal (quat-mult q (quat-identity)) q))
    ;; todo add more tests
    ))

(ert-deftest test-quat-conjugate ()
  (let ((q (make-quat :x 1 :y 2 :z 3 :w 4)))
    (should (= (quat-w (quat-mult q (quat-conjugate q))) (expt (quat-norm q) 2)))
    (should (= (quat-w (quat-conjugate q)) (quat-w q)))
    (should (= (quat-x (quat-conjugate q)) (- (quat-x q))))
    (should (= (quat-y (quat-conjugate q)) (- (quat-y q))))
    (should (= (quat-z (quat-conjugate q)) (- (quat-z q))))))

(ert-deftest test-quat-apply ()
  (let ((q (make-quat-angle-axis (/ pi 2) (make-vec3 :x 0 :y 0 :z 1)))
        (i (make-vec3 :x 1 :y 0 :z 0)))
    (should (equal (quat-apply q i) (make-vec3 :x 0 :y 1 :z 0)))
))

(provide 'quat)
